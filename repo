#!/bin/bash

# (C) 2014 David Greaves david.greaves@jolla.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# See http://www.gnu.org/licenses/gpl-2.0.html for full license text.

STORE=/srv/service/repo
# Note the CACHE *must* be on the same fs as the STORE (and OUTDIR)
# to avoid inter-fs copying.
CACHE=/srv/service/repo/.cache
SVC=""
REPO=""
OUTDIR=""
URL=""
LOCK="$STORE/service_running.pid"
SERVICES="github|mer|jolla"
repocmd=/usr/bin/repo

WAIT_MINS=480 # in mins

get_lock_which_releases_on_exit() {
    (( WAIT=WAIT_MINS*10 )) # 6 second polling
    # Wait for any lockfile to be removed for a max of WAIT_MINS
    c=1
    while [ -f $LOCK ] && (( c < $WAIT )); do
	# Check for stale lock
	pid=$(cat $LOCK)
	if ! kill -0 $pid > /dev/null ; then
	    echo "Detected stale lock - running"
	    rm -f $LOCK
	else
	    echo "repo service lock exists. Waiting"
	    (( c++ ))
	    sleep 6
	fi
    done
    if (( c >= $WAIT )); then
	echo "repo service could not run within $WAIT_MINS mins"
	exit 1
    fi

    # Set a trap to cleanup if we exit
    trap 'tidy_up_and_remove_lock' EXIT
    echo "$$" > $LOCK
}

usage() {
  cat <<EOF
Usage: $0 --service <service> --initrepo <path/pkg> --branch <branch> | --tag <tag>  [--outdir <outdir>]
Options:
  --service <service>      Git hosting service to use ($SERVICES)
  --initrepo <path/pkg>    Repository path to check out
  --branch <branch>        Branch to use for repo init
  --tag <tag>              Tag to use for repo init
  --outdir <outdir>        Move files to outdir after checkout (optional)

Examples:
  $0 --service github --initrepo mer-hybris/android --branch hybris-10.1

Only one instance of this service can run at once.

EOF
}

fatal() {
    usage
    echo $@
    exit 1
}

repo_init() {
    # Get the manifest
    if ! $repocmd init -u $URL -b $BRANCH; then
	fatal "command 'repo init -u $URL -b $BRANCH' returned an error"
    fi
}

use_repo_local() {
    if [[ -d .repo/manifests/local_manifests ]]; then
        echo "Using local_manifests"
        ln -s manifests/local_manifests/ .repo/
    fi
}

repo_sync() {
    # Get the git repos
    $repocmd sync --fetch-submodules || fatal "'repo sync' command failed"
}

store_manifest() {
    # Store the manifest for use in packaging
    $repocmd manifest -r -o repo_service_manifest.xml  || fatal "'repo manifest' command failed"
}

process_spec_files() {
    # Pre-process all the .spec files in rpm/ and actually replace %include with the included file
    for spec in rpm/*.spec; do
	perl -i -ne 'BEGIN { sub pinc {if (/^%include\s+([\w-.\/]+)$/) { print "# repo service performed : %%include $1\n"; local (*I); open I,"<$1" or print "# Couldnt open $1\n"; while (<I>) { pinc(); }; } else { print $_; }}} pinc;' $spec
    done
}

check_cache_and_exit_if_hit() {
    # We only check the cache if *every* project has a "revision" attribute
    # since any project without one may have changed
    MANIFEST=.repo/manifests/default.xml
    grep "<project" $MANIFEST | grep -vq "revision" && return

    # Check the cache:
    SHA1=$(sha1sum $MANIFEST | cut -f1 -d" ")
    if  [[ -f ${CACHE}/${SHA1}_repo.tar.bzip2 ]] && \
	[[ -f ${CACHE}/${SHA1}_rpm.tar.bzip2 ]] && \
	[[ -f ${CACHE}/${SHA1}_cache.tar.bzip2 ]] ; then
	# Found a full cache; move the big tarball and the rpm/
	# subtree tarball to cwd
	# use a hard link to avoid a wasteful copy
	ln ${CACHE}/${SHA1}_repo.tar.bzip2 ${CACHE}/${SHA1}_rpm.tar.bzip2 $OUTDIR
	# and unpack any files into $OUTDIR
	tar xjf ${CACHE}/${SHA1}_rpmfiles.tar.bzip2 -C $OUTDIR
	echo "Used cached tarballs - done"
	exit 0
    else
	echo "No cached tarballs found. Continuing to build a new tarball set"
	return
    fi
}

create_tarballs() {
    find . -mindepth 1 -maxdepth 1 -not \( -name .repo -o -name rpm \) -print | tar c --bzip2 -f repo.tar.bzip2 --files-from -  || fatal "'tar' command failed creating repo.tar.bzip2"
	# Now store any subdirs and symlinks in rpm/ that need keeping
	# SOURCE: files are moved directly to $OUTDIR
	(cd rpm; find . -mindepth 1 -maxdepth 1 \( -type d -o -type l \) -print  | tar c --bzip2 -f ../rpm.tar.bzip2 --files-from - ) || fatal "'tar' command failed creating rpm.tar.bzip2"
}

cache_results() {
    # Use the newly created repo_service_manifest.xml as the key for
    # these tarballs:
    SHA1=$(sha1sum repo_service_manifest.xml | cut -f1 -d" ")

    ln repo.tar.bzip2 ${CACHE}/${SHA1}_repo.tar.bzip2
    ln rpm.tar.bzip2 ${CACHE}/${SHA1}_rpm.tar.bzip2
    # The files (not dirs) in rpm/* will be needed
    (cd rpm; find . -mindepth 1 -maxdepth 1 -type f -print  | tar c  --files-from - --bzip2 -C $OUTDIR -f ${CACHE}/${SHA1}_rpmfiles.tar.bzip2 )
    
    echo "Tarballs have been cached as :"
    ls -laF ${CACHE}/${SHA1}*
}

move_package_files() {
    if [ ! -z "$OUTDIR" ]; then
	# Move all files to OUTDIR
	mv repo.tar.bzip2 "$OUTDIR"
	(cd rpm; find . -mindepth 1 -maxdepth 1 -type f | xargs -I '{}' mv '{}' "$OUTDIR")
	mv rpm.tar.bzip2 "$OUTDIR"
    fi
}

tidy_up() {
    # Only clean up if we can enter the STORE directory
    cd $STORE && find . -mindepth 1 -maxdepth 1 -not -name .repo -and -not -name service_running.pid -print0 | xargs -0 rm -rf
}

tidy_up_and_remove_lock() {
    tidy_up
    rm -f $LOCK
}


while test $# -gt 0; do
  case $1 in
    *-service)
      SVC="$2"
      shift
    ;;
    *-initrepo)
      REPO="$2"
      shift
    ;;
    *-branch)
      BRANCH="$2"
      shift
    ;;
    *-tag)
      TAG="$2"
      shift
    ;;
    *-outdir)
      OUTDIR="$2"
      shift
    ;;
    -h|*-help)
      usage
      exit 0
    ;;
    *)
      usage
      echo Unknown parameter $1.
      exit 1
    ;;
  esac
  shift
done

if [ -z "$SVC" ]; then
    fatal "ERROR: no --service parameter ($SERVICES)"
fi
if [ -z "$REPO" ]; then
    fatal "ERROR: no --initrepo parameter"
fi
if [ -z "$BRANCH" ]; then
    fatal "ERROR: no --branch parameter"
fi

repo_regexp="^[A-Za-z0-9_-]*/[A-Za-z0-9_-]*$"
if ! [[ $REPO =~ $repo_regexp ]]; then
    fatal "ERROR: repo '$REPO'is not in area/repo format (omit .git and any http://.../ part)"
fi


WORKDIR=""

tag_regexp="^[A-Za-z0-9_.-]*$"
if ! [[ $TAG =~ $tag_regexp ]]; then
    fatal "ERROR: repo '$TAG'is not valid (must match '$tag_regexp')"
fi

case "$SVC" in
    github)
        URL="git://github.com/${REPO}.git" ;;
    mer)
        URL="http://git.merproject.org/${REPO}.git/" ;;
    jolla)
        URL="https://git.jollamobile.com/${REPO}.git/" ;;
    *)
        echo "Sorry, git service $SVC is not whitelisted. please contact lbt in #mer"
        exit 1 ;;
esac

PRJDIR=$(pwd)

if [[ ! -d $STORE ]]; then
    echo "Note: $STORE path not found. Creating a local repo directory."
    STORE=./repo.tmp
    mkdir -p $STORE || fatal "Could not create $STORE"
fi

cd $STORE

get_lock_which_releases_on_exit
tidy_up
repo_init
check_cache_and_exit_if_hit
use_repo_local
repo_sync
store_manifest
process_spec_files
create_tarballs
cache_results
move_package_files
tidy_up

exit 0
